# App.jsx <- container
# Container.jsx <- Footer, Header, Input, List
# List.jsx <- Card

🌟 많이 쓰는 pseudo-element TOP 3
① before
.title::before {
  content: "🔥";
}

➡️ 요소 앞에 내용 추가

② after
.title::after {
  content: "✨";
}

➡️ 요소 뒤에 추가

③ placeholder (지금 배우는 것)
input::placeholder {
  color: gray;
}
😎 실무 팁 (초보 거의 모름)

placeholder는 기본적으로:

opacity: 0.5;

가 적용돼 있어서 색이 흐려 보임.

그래서 실무는 보통:

input::placeholder {
  opacity: 1;
}

도 같이 씀.

🧩 많이 쓰는 cursor 종류 (진짜 자주 만남)
cursor: default;   /* 기본 화살표 */
cursor: pointer;   /* 손가락 (클릭) */
cursor: text;      /* 텍스트 입력 */
cursor: move;      /* 이동 */
cursor: not-allowed; /* 금지 */

😎 너 TODO 프로젝트 기준 팁

보통 이렇게 씀:

.btn {
  cursor: pointer;
}

그리고 비활성일 때 👇

.btn:disabled {
  cursor: not-allowed;
}

➡️ UX 갑자기 좋아짐.

🔥 근데 여기 진짜 실무 꿀팁 하나

초보들이 많이 하는 실수:

div {
  cursor: pointer;
}

❌ 이런 거 막 쓰면 안 됨.

왜냐면:

➡️ 클릭 안 되는데 클릭되는 것처럼 보여서 UX 망함.

[브라우저]
"안녕"
   ↓
JS 객체
   ↓ JSON.stringify
JSON 문자열
   ↓ HTTP
[서버]
JSON 문자열
   ↓ 자동 변환 (@RequestBody)
Java 객체
   ↓
DB 저장

# pagination
1. 전체 흐름 요약
  1) 최초 진입
  - container 마운트
  - getList() 실행 -> GET /todos (기본 1페이지)
  - 응답
    - todoList (초기 리스트)
    - initialPagination (페이지 정보) -> state 저장
    - List로 todoList, initialPagination 전달
  2) List: 초기 페이지(0번) 만들기
  - props로 받은 todoList + initialPagination 묶어서
    - pageNum: 0
    - data: todoList
    - pagination: initialPagination 형태의 initialPage 생성
  - pages state에 [initialPage] 형태로 저장 (이미 있다면 업데이트)
  3) 스크롤: 다음 페이지 로딩
  - nextpage = currentPageRef.current + 1
  - addPage(nextPage) -> GET /todos?page=n
  - 응답 오면 'page' 에 {pageNum: n, data: list, pagination} 누적 추가
  - 화면엔 <Page /> 컴포넌트가 페이지 수만큼 생성되고, 각 Page 안에 Card 리스트 렌더링

2. 컴포넌트별 역할
  1) Container
  - "서버의 기본 목록(첫 페이지)"
  - getList(): 초기 목록과 pagination 새로 가져옴
      * 등록/삭제/완료 후에도 초기 목록 갱신
  - listKey: <List key={listKey} /> 통째로 리셋
  즉, 초기 페이지의 진실 소스 느낌
  2) List
  - 페이지들을 누적해서 보여주는 컨테이너
  - 내부 state
    - pages: 페이지 묶음 배열 (여기에 page들 쌓임)
    - currentPage: 지금 어디까지 불렀는가
    - lastPage: 마지막 페이지 번호
  - useRef
    - 스크롤 이벤트 핸들러는 이벤트 리스너로 등록되면, 예전 값 잡고 있으므로, 최신 currentPage/lastPage 참조하려고 ref로 보관
  - pages (배열) 렌더링
    - pages.map(page => <Page key={`page-${page.pageNum}`} ... />)
  3) Page
  - 페이지 하나 렌더링하고, 그 페이지 단독으로 토글/삭제 처리
  - 초기페이지(0번) 특별 취급
    - 토글/삭제 시 부모Container의 onToggle, onRemove 사용
    - refresh도 getList() 사용
  - 0번 아닌 페이지
    - 토글/삭제 시 서버 요청 후 refreshPage()로 해당 페이지 다시 fetch
  즉, 페이지 단위의 독립성
  
